{
    "summary": "The code involves dataclasses, enums for slicing activation records, ensures disjoint and covering slices, obtains interleaved subsets for training, validation, explanation evaluations, checks neuron existence, fetches neuron data from a file, ensures compatibility with NeuronRecord dataclass, provides options for synchronous/asynchronous processing, retrieves fold names in numeric order from the \"neurons\" directory.",
    "details": [
        {
            "comment": "Defines dataclasses and enums for storing information about neuron-indexed activations, along with related helper functions.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":0-32",
            "content": "# Dataclasses and enums for storing neuron-indexed information about activations. Also, related\n# helper functions.\nimport math\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Union\nimport urllib.request\nimport blobfile as bf\nimport boostedblob as bbb\nfrom neuron_explainer.fast_dataclasses import FastDataclass, loads, register_dataclass\nfrom neuron_explainer.azure import standardize_azure_url\n@register_dataclass\n@dataclass\nclass ActivationRecord(FastDataclass):\n    \"\"\"Collated lists of tokens and their activations for a single neuron.\"\"\"\n    tokens: List[str]\n    \"\"\"Tokens in the text sequence, represented as strings.\"\"\"\n    activations: List[float]\n    \"\"\"Raw activation values for the neuron on each token in the text sequence.\"\"\"\n@register_dataclass\n@dataclass\nclass NeuronId(FastDataclass):\n    \"\"\"Identifier for a neuron in an artificial neural network.\"\"\"\n    layer_index: int\n    \"\"\"The index of layer the neuron is in. The first layer used during inference has index 0.\"\"\"\n    neuron_index: int"
        },
        {
            "comment": "This code defines two functions: `_check_slices` and `get_slices_for_splits`.\n- `_check_slices` checks if slices are disjoint and fully cover the intended range.\n- `get_slices_for_splits` gets equal-sized interleaved subsets for a list of splits.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":33-63",
            "content": "    \"\"\"The neuron's index within in its layer. Indices start from 0 in each layer.\"\"\"\ndef _check_slices(\n    slices_by_split: dict[str, slice],\n    expected_num_values: int,\n) -> None:\n    \"\"\"Assert that the slices are disjoint and fully cover the intended range.\"\"\"\n    indices = set()\n    sum_of_slice_lengths = 0\n    n_splits = len(slices_by_split.keys())\n    for s in slices_by_split.values():\n        subrange = range(expected_num_values)[s]\n        sum_of_slice_lengths += len(subrange)\n        indices |= set(subrange)\n    assert (\n        sum_of_slice_lengths == expected_num_values\n    ), f\"{sum_of_slice_lengths=} != {expected_num_values=}\"\n    stride = n_splits\n    expected_indices = set.union(\n        *[set(range(start_index, expected_num_values, stride)) for start_index in range(n_splits)]\n    )\n    assert indices == expected_indices, f\"{indices=} != {expected_indices=}\"\ndef get_slices_for_splits(\n    splits: list[str],\n    num_activation_records_per_split: int,\n) -> dict[str, slice]:\n    \"\"\"\n    Get equal-sized interleaved subsets for each of a list of splits, given the number of elements"
        },
        {
            "comment": "This code defines a class for ActivationRecordSliceParams, which specifies how to slice activation records based on the number of examples per split. It also includes a dataclass NeuronRecord that stores neuron-indexed activation data with summary stats and notable activation records.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":64-98",
            "content": "    to include in each split.\n    \"\"\"\n    stride = len(splits)\n    num_activation_records_for_even_splits = num_activation_records_per_split * stride\n    slices_by_split = {\n        split: slice(split_index, num_activation_records_for_even_splits, stride)\n        for split_index, split in enumerate(splits)\n    }\n    _check_slices(\n        slices_by_split=slices_by_split,\n        expected_num_values=num_activation_records_for_even_splits,\n    )\n    return slices_by_split\n@dataclass\nclass ActivationRecordSliceParams:\n    \"\"\"How to select splits (train, valid, etc.) of activation records.\"\"\"\n    n_examples_per_split: Optional[int]\n    \"\"\"The number of examples to include in each split.\"\"\"\n@register_dataclass\n@dataclass\nclass NeuronRecord(FastDataclass):\n    \"\"\"Neuron-indexed activation data, including summary stats and notable activation records.\"\"\"\n    neuron_id: NeuronId\n    \"\"\"Identifier for the neuron.\"\"\"\n    random_sample: list[ActivationRecord] = field(default_factory=list)\n    \"\"\"\n    Random activation records for this neuron. The random sample is independent from those used for"
        },
        {
            "comment": "This code represents a class for neuron activation records. It has attributes for random samples at specific quantiles, quantile boundaries, and moments of the activation values (mean, variance, skewness, kurtosis). Additionally, it includes a list of most positive activation records and a property to return the maximum activation value across all top-activating activation records.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":99-124",
            "content": "    other neurons.\n    \"\"\"\n    random_sample_by_quantile: Optional[list[list[ActivationRecord]]] = None\n    \"\"\"\n    Random samples of activation records in each of the specified quantiles. None if quantile\n    tracking is disabled.\n    \"\"\"\n    quantile_boundaries: Optional[list[float]] = None\n    \"\"\"Boundaries of the quantiles used to generate the random_sample_by_quantile field.\"\"\"\n    # Moments of activations\n    mean: Optional[float] = math.nan\n    variance: Optional[float] = math.nan\n    skewness: Optional[float] = math.nan\n    kurtosis: Optional[float] = math.nan\n    most_positive_activation_records: list[ActivationRecord] = field(default_factory=list)\n    \"\"\"\n    Activation records with the most positive figure of merit value for this neuron over all dataset\n    examples.\n    \"\"\"\n    @property\n    def max_activation(self) -> float:\n        \"\"\"Return the maximum activation value over all top-activating activation records.\"\"\"\n        return max([max(ar.activations) for ar in self.most_positive_activation_records])"
        },
        {
            "comment": "Code defines two methods, _get_top_activation_slices and _get_random_activation_slices, which return slices for activation records based on specified parameters. These slices are used to select a subset of the activation records for further processing.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":126-143",
            "content": "    def _get_top_activation_slices(\n        self, activation_record_slice_params: ActivationRecordSliceParams\n    ) -> dict[str, slice]:\n        splits = [\"train\", \"calibration\", \"valid\", \"test\"]\n        n_examples_per_split = activation_record_slice_params.n_examples_per_split\n        if n_examples_per_split is None:\n            n_examples_per_split = len(self.most_positive_activation_records) // len(splits)\n        assert len(self.most_positive_activation_records) >= n_examples_per_split * len(splits)\n        return get_slices_for_splits(splits, n_examples_per_split)\n    def _get_random_activation_slices(\n        self, activation_record_slice_params: ActivationRecordSliceParams\n    ) -> dict[str, slice]:\n        splits = [\"calibration\", \"valid\", \"test\"]\n        n_examples_per_split = activation_record_slice_params.n_examples_per_split\n        if n_examples_per_split is None:\n            n_examples_per_split = len(self.random_sample) // len(splits)\n        # NOTE: this assert could trigger on some ol"
        },
        {
            "comment": "The code defines three methods: \"get_slices_for_splits\", \"train_activation_records\", and \"calibration_activation_records\".\n\"get_slices_for_splits\" returns slices for the specified splits based on the given number of examples per split.\n\"train_activation_records\" retrieves activation records from the \"most_positive_activation_records\" list for the training split.\n\"calibration_activation_records\" retrieves activation records for the calibration split.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":143-165",
            "content": "d datasets with only 10 random samples, in which case you may have to remove \"test\" from the set of splits\n        assert len(self.random_sample) >= n_examples_per_split * len(splits)\n        return get_slices_for_splits(splits, n_examples_per_split)\n    def train_activation_records(\n        self,\n        activation_record_slice_params: ActivationRecordSliceParams,\n    ) -> list[ActivationRecord]:\n        \"\"\"\n        Train split, typically used for generating explanations. Consists exclusively of\n        top-activating records since context window limitations make it difficult to include\n        random records.\n        \"\"\"\n        return self.most_positive_activation_records[\n            self._get_top_activation_slices(activation_record_slice_params)[\"train\"]\n        ]\n    def calibration_activation_records(\n        self,\n        activation_record_slice_params: ActivationRecordSliceParams,\n    ) -> list[ActivationRecord]:\n        \"\"\"\n        Calibration split, typically used for calibrating neuron simulations. See"
        },
        {
            "comment": "This code defines two methods: \"calibration\" and \"valid_activation_records\". Both methods return a combination of top-activating records and random records in a 1:1 ratio, which can be used for explanation validation or evaluation.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":166-189",
            "content": "        http://go/neuron_explanation_methodology for an explanation of calibration. Consists of\n        top-activating records and random records in a 1:1 ratio.\n        \"\"\"\n        return (\n            self.most_positive_activation_records[\n                self._get_top_activation_slices(activation_record_slice_params)[\"calibration\"]\n            ]\n            + self.random_sample[\n                self._get_random_activation_slices(activation_record_slice_params)[\"calibration\"]\n            ]\n        )\n    def valid_activation_records(\n        self,\n        activation_record_slice_params: ActivationRecordSliceParams,\n    ) -> list[ActivationRecord]:\n        \"\"\"\n        Validation split, typically used for evaluating explanations, either automatically with\n        simulation + correlation coefficient scoring, or manually by humans. Consists of\n        top-activating records and random records in a 1:1 ratio.\n        \"\"\"\n        return (\n            self.most_positive_activation_records[\n                self._get_top_activation_slices(activation_record_slice_params)[\"valid\"]"
        },
        {
            "comment": "The code defines three functions:\n1. \"get_activation_slices\": returns activation slices for training and validation splits based on the given parameters.\n2. \"test_activation_records\": returns a list of activation records used for explanation evaluations that can't use the validation split, containing top-activating records and random records in a 1:1 ratio.\n3. \"neuron_exists\": checks if a specified neuron exists based on given dataset path, layer index, and neuron index.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":190-218",
            "content": "            ]\n            + self.random_sample[\n                self._get_random_activation_slices(activation_record_slice_params)[\"valid\"]\n            ]\n        )\n    def test_activation_records(\n        self,\n        activation_record_slice_params: ActivationRecordSliceParams,\n    ) -> list[ActivationRecord]:\n        \"\"\"\n        Test split, typically used for explanation evaluations that can't use the validation split.\n        Consists of top-activating records and random records in a 1:1 ratio.\n        \"\"\"\n        return (\n            self.most_positive_activation_records[\n                self._get_top_activation_slices(activation_record_slice_params)[\"test\"]\n            ]\n            + self.random_sample[\n                self._get_random_activation_slices(activation_record_slice_params)[\"test\"]\n            ]\n        )\ndef neuron_exists(\n    dataset_path: str, layer_index: Union[str, int], neuron_index: Union[str, int]\n) -> bool:\n    \"\"\"Return whether the specified neuron exists.\"\"\"\n    file = bf.join(dataset_path, \"neurons\", str(layer_index), f\"{neuron_index}.json\")"
        },
        {
            "comment": "This code contains two functions, `load_neuron` and an asynchronous version `load_neuron_async`, that fetch NeuronRecord data from a specified neuron. It first constructs the URL to the dataset based on layer index and neuron index, then opens the URL and reads the JSON data. If the read data is not of type NeuronRecord, it raises an error. The asynchronous version uses BigBangEngine's `ensure_session` decorator for asynchronous execution.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":219-246",
            "content": "    return bf.exists(file)\ndef load_neuron(\n    layer_index: Union[str, int],\n    neuron_index: Union[str, int],\n    dataset_path: str = \"https://openaipublic.blob.core.windows.net/neuron-explainer/data/collated-activations\",\n) -> NeuronRecord:\n    \"\"\"Load the NeuronRecord for the specified neuron.\"\"\"\n    url = \"/\".join([dataset_path, str(layer_index), f\"{neuron_index}.json\"])\n    url = standardize_azure_url(url)\n    with urllib.request.urlopen(url) as f:\n        neuron_record = loads(f.read())\n        if not isinstance(neuron_record, NeuronRecord):\n            raise ValueError(\n                f\"Stored data incompatible with current version of NeuronRecord dataclass.\"\n            )\n        return neuron_record\n@bbb.ensure_session\nasync def load_neuron_async(\n    layer_index: Union[str, int],\n    neuron_index: Union[str, int],\n    dataset_path: str = \"az://openaipublic/neuron-explainer/data/collated-activations\",\n) -> NeuronRecord:\n    \"\"\"Async version of load_neuron.\"\"\"\n    file = bf.join(dataset_path, str(layer_index), f\"{neuron_index}.json\")"
        },
        {
            "comment": "This code retrieves neuron data from a file, checks its compatibility with the NeuronRecord dataclass, and provides functions to get sorted layer indices and layer names for a given dataset.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":247-272",
            "content": "    return await read_neuron_file(file)\n@bbb.ensure_session\nasync def read_neuron_file(neuron_filename: str) -> NeuronRecord:\n    \"\"\"Like load_neuron_async, but takes a raw neuron filename.\"\"\"\n    raw_contents = await bbb.read.read_single(neuron_filename)\n    neuron_record = loads(raw_contents.decode(\"utf-8\"))\n    if not isinstance(neuron_record, NeuronRecord):\n        raise ValueError(\n            f\"Stored data incompatible with current version of NeuronRecord dataclass.\"\n        )\n    return neuron_record\ndef get_sorted_neuron_indices(dataset_path: str, layer_index: Union[str, int]) -> List[int]:\n    \"\"\"Returns the indices of all neurons in this layer, in ascending order.\"\"\"\n    layer_dir = bf.join(dataset_path, \"neurons\", str(layer_index))\n    return sorted(\n        [int(f.split(\".\")[0]) for f in bf.listdir(layer_dir) if f.split(\".\")[0].isnumeric()]\n    )\ndef get_sorted_layers(dataset_path: str) -> List[str]:\n    \"\"\"\n    Return the indices of all layers in this dataset, in ascending numerical order, as strings."
        },
        {
            "comment": "Gets numeric fold names from \"neurons\" directory and sorts them.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/activations/activations.py\":273-279",
            "content": "    \"\"\"\n    return [\n        str(x)\n        for x in sorted(\n            [int(x) for x in bf.listdir(bf.join(dataset_path, \"neurons\")) if x.isnumeric()]\n        )\n    ]"
        }
    ]
}