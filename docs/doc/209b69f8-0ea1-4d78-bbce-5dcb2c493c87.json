{
    "summary": "The CalibratedNeuronSimulator improves NeuronSimulator with calibration methods, while the LinearCalibratedNeuronSimulator uses flattened activations and true activations for calibration, and PercentileMatchingCalibratedNeuronSimulator ensures distribution matching on the calibration set.",
    "details": [
        {
            "comment": "CalibratedNeuronSimulator class inherits from NeuronSimulator and provides calibration for mapping predicted activation values to real neuron activations.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/calibrated_simulator.py\":0-26",
            "content": "\"\"\"\nCode for calibrating simulations of neuron behavior. Calibration refers to a process of mapping from\na space of predicted activation values (e.g. [0, 10]) to the real activation distribution for a\nneuron.\nSee http://go/neuron_explanation_methodology for description of calibration step. Necessary for\nsimulating neurons in the context of ablate-to-simulation, but can be skipped when using correlation\nscoring. (Calibration may still improve quality for scoring, at least for non-linear calibration\nmethods.)\n\"\"\"\nfrom __future__ import annotations\nimport asyncio\nfrom abc import abstractmethod\nfrom typing import Optional, Sequence\nimport numpy as np\nfrom neuron_explainer.activations.activations import ActivationRecord\nfrom neuron_explainer.explanations.explanations import ActivationScale\nfrom neuron_explainer.explanations.simulator import NeuronSimulator, SequenceSimulation\nfrom sklearn import linear_model\nclass CalibratedNeuronSimulator(NeuronSimulator):\n    \"\"\"\n    Wrap a NeuronSimulator and calibrate it to map from the predicted activation space to the"
        },
        {
            "comment": "This code defines a class method `create()` and a method `calibrate()` for the `CalibratedNeuronSimulator` class. The `create()` method creates and calibrates a simulator in one call, while the `calibrate()` method determines parameters to map from predicted activation space to real neuron activation space based on a calibration set.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/calibrated_simulator.py\":27-52",
            "content": "    actual neuron activation space.\n    \"\"\"\n    def __init__(self, uncalibrated_simulator: NeuronSimulator):\n        self.uncalibrated_simulator = uncalibrated_simulator\n    @classmethod\n    async def create(\n        cls,\n        uncalibrated_simulator: NeuronSimulator,\n        calibration_activation_records: Sequence[ActivationRecord],\n    ) -> CalibratedNeuronSimulator:\n        \"\"\"\n        Create and calibrate a calibrated simulator (so initialization and calibration can be done\n        in one call).\n        \"\"\"\n        calibrated_simulator = cls(uncalibrated_simulator)\n        await calibrated_simulator.calibrate(calibration_activation_records)\n        return calibrated_simulator\n    async def calibrate(self, calibration_activation_records: Sequence[ActivationRecord]) -> None:\n        \"\"\"\n        Determine parameters to map from the predicted activation space to the real neuron\n        activation space, based on a calibration set.\n        Use when simulated sequences haven't already been produced on the calibration set."
        },
        {
            "comment": "Calibrating simulator by generating flattened activation sequences for both calibration_activation_records and simulations.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/calibrated_simulator.py\":53-77",
            "content": "        \"\"\"\n        simulations = await asyncio.gather(\n            *[\n                self.uncalibrated_simulator.simulate(activations.tokens)\n                for activations in calibration_activation_records\n            ]\n        )\n        self.calibrate_from_simulations(calibration_activation_records, simulations)\n    def calibrate_from_simulations(\n        self,\n        calibration_activation_records: Sequence[ActivationRecord],\n        simulations: Sequence[SequenceSimulation],\n    ) -> None:\n        \"\"\"\n        Determine parameters to map from the predicted activation space to the real neuron\n        activation space, based on a calibration set.\n        Use when simulated sequences have already been produced on the calibration set.\n        \"\"\"\n        flattened_activations = []\n        flattened_simulated_activations: list[float] = []\n        for activations, simulation in zip(calibration_activation_records, simulations):\n            flattened_activations.extend(activations.activations)\n            flattened_simulated_activations.extend(simulation.expected_activations)"
        },
        {
            "comment": "This code defines a calibrated simulator that can be used to map the predicted activation space of a model to the actual neuron activation space. It contains methods for calibration and applying calibration to sequences of values. The simulate method is also defined, which uses an uncalibrated simulator to obtain expected activations and applies the calibration to obtain the final calibrated activations.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/calibrated_simulator.py\":78-103",
            "content": "        self._calibrate_from_flattened_activations(\n            np.array(flattened_activations), np.array(flattened_simulated_activations)\n        )\n    @abstractmethod\n    def _calibrate_from_flattened_activations(\n        self,\n        true_activations: np.ndarray,\n        uncalibrated_activations: np.ndarray,\n    ) -> None:\n        \"\"\"\n        Determine parameters to map from the predicted activation space to the real neuron\n        activation space, based on a calibration set.\n        Take numpy arrays of all true activations and all uncalibrated activations on the\n        calibration set over all sequences.\n        \"\"\"\n    @abstractmethod\n    def apply_calibration(self, values: Sequence[float]) -> list[float]:\n        \"\"\"Apply the learned calibration to a sequence of values.\"\"\"\n    async def simulate(self, tokens: Sequence[str]) -> SequenceSimulation:\n        uncalibrated_seq_simulation = await self.uncalibrated_simulator.simulate(tokens)\n        calibrated_activations = self.apply_calibration(\n            uncalibrated_seq_simulation.expected_activations"
        },
        {
            "comment": "CalibratedNeuronSimulator applies calibration to uncalibrated sequence simulation. UncalibratedNeuronSimulator passes through activations without calibration.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/calibrated_simulator.py\":104-128",
            "content": "        )\n        calibrated_distribution_values = [\n            self.apply_calibration(dv) for dv in uncalibrated_seq_simulation.distribution_values\n        ]\n        return SequenceSimulation(\n            tokens=uncalibrated_seq_simulation.tokens,\n            expected_activations=calibrated_activations,\n            activation_scale=ActivationScale.NEURON_ACTIVATIONS,\n            distribution_values=calibrated_distribution_values,\n            distribution_probabilities=uncalibrated_seq_simulation.distribution_probabilities,\n            uncalibrated_simulation=uncalibrated_seq_simulation,\n        )\nclass UncalibratedNeuronSimulator(CalibratedNeuronSimulator):\n    \"\"\"Pass through the activations without trying to calibrate.\"\"\"\n    def __init__(self, uncalibrated_simulator: NeuronSimulator):\n        super().__init__(uncalibrated_simulator)\n    async def calibrate(self, calibration_activation_records: Sequence[ActivationRecord]) -> None:\n        pass\n    def _calibrate_from_flattened_activations(\n        self,"
        },
        {
            "comment": "This code defines a class `LinearCalibratedNeuronSimulator` that inherits from `CalibratedNeuratorSimulator`. It initializes an optional linear regression model and provides two methods. The method `_calibrate_from_flattened_activations` fits the linear regression model with flattened uncalibrated activations and true activations, and the method `apply_calibration` applies the calibration to a given sequence of values if they are a list.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/calibrated_simulator.py\":129-156",
            "content": "        true_activations: np.ndarray,\n        uncalibrated_activations: np.ndarray,\n    ) -> None:\n        pass\n    def apply_calibration(self, values: Sequence[float]) -> list[float]:\n        return values if isinstance(values, list) else list(values)\nclass LinearCalibratedNeuronSimulator(CalibratedNeuronSimulator):\n    \"\"\"Find a linear mapping from uncalibrated activations to true activations.\n    Should not change ev_correlation_score because it is invariant to linear transformations.\n    \"\"\"\n    def __init__(self, uncalibrated_simulator: NeuronSimulator):\n        super().__init__(uncalibrated_simulator)\n        self._regression: Optional[linear_model.LinearRegression] = None\n    def _calibrate_from_flattened_activations(\n        self,\n        true_activations: np.ndarray,\n        uncalibrated_activations: np.ndarray,\n    ) -> None:\n        self._regression = linear_model.LinearRegression()\n        self._regression.fit(uncalibrated_activations.reshape(-1, 1), true_activations)\n    def apply_calibration(self, values: Sequence[float]) -> list[float]:"
        },
        {
            "comment": "This code defines a `PercentileMatchingCalibratedNeuronSimulator` class that calibrates a neuron simulator by mapping the nth percentile of uncalibrated activations to the nth percentile of true activations for all n. This will match the distribution of true activations on the calibration set but will be overconfident outside of it. The `__init__` method initializes an instance with an optional `uncalibrated_simulator`, and the `_calibrate_from_flattened_activations` method performs the actual calibration using true activations and uncalibrated activations as inputs.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/calibrated_simulator.py\":157-183",
            "content": "        if self._regression is None:\n            raise ValueError(\"Must call calibrate() before apply_calibration\")\n        if len(values) == 0:\n            return []\n        return self._regression.predict(np.reshape(np.array(values), (-1, 1))).tolist()\nclass PercentileMatchingCalibratedNeuronSimulator(CalibratedNeuronSimulator):\n    \"\"\"\n    Map the nth percentile of the uncalibrated activations to the nth percentile of the true\n    activations for all n.\n    This will match the distribution of true activations on the calibration set, but will be\n    overconfident outside of the calibration set.\n    \"\"\"\n    def __init__(self, uncalibrated_simulator: NeuronSimulator):\n        super().__init__(uncalibrated_simulator)\n        self._uncalibrated_activations: Optional[np.ndarray] = None\n        self._true_activations: Optional[np.ndarray] = None\n    def _calibrate_from_flattened_activations(\n        self,\n        true_activations: np.ndarray,\n        uncalibrated_activations: np.ndarray,\n    ) -> None:\n        self._uncalibrated_activations = np.sort(uncalibrated_activations)"
        },
        {
            "comment": "Sorting true_activations for calibration and raising ValueError if calibrate() not called before apply_calibration.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/calibrated_simulator.py\":184-193",
            "content": "        self._true_activations = np.sort(true_activations)\n    def apply_calibration(self, values: Sequence[float]) -> list[float]:\n        if self._true_activations is None or self._uncalibrated_activations is None:\n            raise ValueError(\"Must call calibrate() before apply_calibration\")\n        if len(values) == 0:\n            return []\n        return np.interp(\n            np.array(values), self._uncalibrated_activations, self._true_activations\n        ).tolist()"
        }
    ]
}