{
    "summary": "The code includes classes for neuron explanations, scores, and simulation results with asynchronous loading from JSON file reading. The function retrieves sorted neuron indices by joining the explanation path with the layer number, listing files, filtering numeric filenames, converting to integers, and sorting the list.",
    "details": [
        {
            "comment": "This code defines dataclasses and enums for storing neuron explanations, scores, and related data. It also includes helper functions and handles different activation scales for neurons.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":0-28",
            "content": "# Dataclasses and enums for storing neuron explanations, their scores, and related data. Also,\n# related helper functions.\nfrom __future__ import annotations\nimport json\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List, Optional, Union\nimport blobfile as bf\nimport boostedblob as bbb\nfrom neuron_explainer.activations.activations import NeuronId\nfrom neuron_explainer.fast_dataclasses import FastDataclass, loads, register_dataclass\nclass ActivationScale(str, Enum):\n    \"\"\"Which \"units\" are stored in the expected_activations/distribution_values fields of a\n    SequenceSimulation.\n    This enum identifies whether the values represent real activations of the neuron or something\n    else. Different scales are not necessarily related by a linear transformation.\n    \"\"\"\n    NEURON_ACTIVATIONS = \"neuron_activations\"\n    \"\"\"Values represent real activations of the neuron.\"\"\"\n    SIMULATED_NORMALIZED_ACTIVATIONS = \"simulated_normalized_activations\"\n    \"\"\"\n    Values represent simulated activations of the neuron, normalized to the range [0, 10]. This"
        },
        {
            "comment": "This code defines a dataclass for storing the results of simulating neuron activations on a text sequence. It includes the sequence of tokens, expected activation values, scale, and distribution values from the simulation, excluding non-significant tokens.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":29-51",
            "content": "    scale is arbitrary and should not be interpreted as a neuron activation.\n    \"\"\"\n@register_dataclass\n@dataclass\nclass SequenceSimulation(FastDataclass):\n    \"\"\"The result of a simulation of neuron activations on one text sequence.\"\"\"\n    tokens: list[str]\n    \"\"\"The sequence of tokens that was simulated.\"\"\"\n    expected_activations: list[float]\n    \"\"\"Expected value of the possibly-normalized activation for each token in the sequence.\"\"\"\n    activation_scale: ActivationScale\n    \"\"\"What scale is used for values in the expected_activations field.\"\"\"\n    distribution_values: list[list[float]]\n    \"\"\"\n    For each token in the sequence, a list of values from the discrete distribution of activations\n    produced from simulation. Tokens will be included here if and only if they are in the top K=15\n    tokens predicted by the simulator, and excluded otherwise.\n    May be transformed to another unit by calibration. When we simulate a neuron, we produce a\n    discrete distribution with values in the arbitrary discretized space of the neuron, e.g. 10%"
        },
        {
            "comment": "This code describes a class called ScoredSequenceSimulation, which stores a distribution of values and their probabilities for each token in a sequence. It also has an optional uncalibrated_simulation attribute representing the simulation before calibration.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":52-72",
            "content": "    chance of 0, 70% chance of 1, 20% chance of 2. Which we store as distribution_values =\n    [0, 1, 2], distribution_probabilities = [0.1, 0.7, 0.2]. When we transform the distribution to\n    the real activation units, we can correspondingly transform the values of this distribution\n    to get a distribution in the units of the neuron. e.g. if the mapping from the discretized space\n    to the real activation unit of the neuron is f(x) = x/2, then the distribution becomes 10%\n    chance of 0, 70% chance of 0.5, 20% chance of 1. Which we store as distribution_values =\n    [0, 0.5, 1], distribution_probabilities = [0.1, 0.7, 0.2].\n    \"\"\"\n    distribution_probabilities: list[list[float]]\n    \"\"\"\n    For each token in the sequence, the probability of the corresponding value in\n    distribution_values.\n    \"\"\"\n    uncalibrated_simulation: Optional[\"SequenceSimulation\"] = None\n    \"\"\"The result of the simulation before calibration.\"\"\"\n@register_dataclass\n@dataclass\nclass ScoredSequenceSimulation(FastDataclass):"
        },
        {
            "comment": "This code defines a ScoredSimulation class that represents the result of scoring a neuron simulation on multiple sequences. It includes properties like simulation, true_activations, ev_correlation_score, and optional rsquared_score and absolute_dev_explained_score for evaluating the simulation's performance.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":73-100",
            "content": "    \"\"\"\n    SequenceSimulation result with a score (for that sequence only) and ground truth activations.\n    \"\"\"\n    simulation: SequenceSimulation\n    \"\"\"The result of a simulation of neuron activations.\"\"\"\n    true_activations: List[float]\n    \"\"\"Ground truth activations on the sequence (not normalized)\"\"\"\n    ev_correlation_score: float\n    \"\"\"\n    Correlation coefficient between the expected values of the normalized activations from the\n    simulation and the unnormalized true activations of the neuron on the text sequence.\n    \"\"\"\n    rsquared_score: Optional[float] = None\n    \"\"\"R^2 of the simulated activations.\"\"\"\n    absolute_dev_explained_score: Optional[float] = None\n    \"\"\"\n    Score based on absolute difference between real and simulated activations.\n    absolute_dev_explained_score = 1 - mean(abs(real-predicted))/ mean(abs(real))\n    \"\"\"\n@register_dataclass\n@dataclass\nclass ScoredSimulation(FastDataclass):\n    \"\"\"Result of scoring a neuron simulation on multiple sequences.\"\"\"\n    scored_sequence_simulations: List[ScoredSequenceSimulation]"
        },
        {
            "comment": "This code defines a class with three score metrics (ev_correlation_score, rsquared_score, absolute_dev_explained_score) for evaluated sequences and provides a get_preferred_score method to return the preferred score.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":101-124",
            "content": "    \"\"\"ScoredSequenceSimulation for each sequence\"\"\"\n    ev_correlation_score: Optional[float] = None\n    \"\"\"\n    Correlation coefficient between the expected values of the normalized activations from the\n    simulation and the unnormalized true activations on a dataset created from all score_results.\n    (Note that this is not equivalent to averaging across sequences.)\n    \"\"\"\n    rsquared_score: Optional[float] = None\n    \"\"\"R^2 of the simulated activations.\"\"\"\n    absolute_dev_explained_score: Optional[float] = None\n    \"\"\"\n    Score based on absolute difference between real and simulated activations.\n    absolute_dev_explained_score = 1 - mean(abs(real-predicted))/ mean(abs(real)).\n    \"\"\"\n    def get_preferred_score(self) -> Optional[float]:\n        \"\"\"\n        This method may return None in cases where the score is undefined, for example if the\n        normalized activations were all zero, yielding a correlation coefficient of NaN.\n        \"\"\"\n        return self.ev_correlation_score\n@register_dataclass"
        },
        {
            "comment": "Class representing simulator parameters and scoring results for multiple sequences.\nFunction returns preferred score or None if undefined (e.g., normalized activations all zero).\nClass represents simulation results and scores for a specific neuron.\nFunction loads scored explanations for the specified neuron from given path.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":125-155",
            "content": "@dataclass\nclass ScoredExplanation(FastDataclass):\n    \"\"\"Simulator parameters and the results of scoring it on multiple sequences\"\"\"\n    explanation: str\n    \"\"\"The explanation used for simulation.\"\"\"\n    scored_simulation: ScoredSimulation\n    \"\"\"Result of scoring the neuron simulator on multiple sequences.\"\"\"\n    def get_preferred_score(self) -> Optional[float]:\n        \"\"\"\n        This method may return None in cases where the score is undefined, for example if the\n        normalized activations were all zero, yielding a correlation coefficient of NaN.\n        \"\"\"\n        return self.scored_simulation.get_preferred_score()\n@register_dataclass\n@dataclass\nclass NeuronSimulationResults(FastDataclass):\n    \"\"\"Simulation results and scores for a neuron.\"\"\"\n    neuron_id: NeuronId\n    scored_explanations: list[ScoredExplanation]\ndef load_neuron_explanations(\n    explanations_path: str, layer_index: Union[str, int], neuron_index: Union[str, int]\n) -> Optional[NeuronSimulationResults]:\n    \"\"\"Load scored explanations for the specified neuron.\"\"\""
        },
        {
            "comment": "1. Loads scored explanations for the specified neuron asynchronously.\n2. Read the contents of the given file as a string, asynchronously.\n3. Splits the content into lines and returns non-empty lines.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":156-185",
            "content": "    file = bf.join(explanations_path, str(layer_index), f\"{neuron_index}.jsonl\")\n    if not bf.exists(file):\n        return None\n    with bf.BlobFile(file) as f:\n        for line in f:\n            return loads(line)\n    return None\n@bbb.ensure_session\nasync def load_neuron_explanations_async(\n    explanations_path: str, layer_index: Union[str, int], neuron_index: Union[str, int]\n) -> Optional[NeuronSimulationResults]:\n    \"\"\"Load scored explanations for the specified neuron, asynchronously.\"\"\"\n    return await read_explanation_file(\n        bf.join(explanations_path, str(layer_index), f\"{neuron_index}.jsonl\")\n    )\n@bbb.ensure_session\nasync def read_file(filename: str) -> Optional[str]:\n    \"\"\"Read the contents of the given file as a string, asynchronously.\"\"\"\n    try:\n        raw_contents = await bbb.read.read_single(filename)\n    except FileNotFoundError:\n        print(f\"Could not read {filename}\")\n        return None\n    lines = []\n    for line in raw_contents.decode(\"utf-8\").split(\"\\n\"):\n        if len(line) > 0:"
        },
        {
            "comment": "- reads explanation file from filename\n- loads scored explanations asynchronously\n- reads the contents of a file as JSON object asynchronously\n- returns names of numbered subdirectories in specified directory",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":186-216",
            "content": "            lines.append(line)\n    assert len(lines) == 1, filename\n    return lines[0]\n@bbb.ensure_session\nasync def read_explanation_file(explanation_filename: str) -> Optional[NeuronSimulationResults]:\n    \"\"\"Load scored explanations from the given filename, asynchronously.\"\"\"\n    line = await read_file(explanation_filename)\n    return loads(line) if line is not None else None\n@bbb.ensure_session\nasync def read_json_file(filename: str) -> Optional[dict]:\n    \"\"\"Read the contents of the given file as a JSON object, asynchronously.\"\"\"\n    line = await read_file(filename)\n    return json.loads(line) if line is not None else None\ndef get_numerical_subdirs(dataset_path: str) -> list[str]:\n    \"\"\"Return the names of all numbered subdirectories in the specified directory.\n    Used to get all layer directories in an explanation directory.\n    \"\"\"\n    return [\n        str(x)\n        for x in sorted(\n            [\n                int(x)\n                for x in bf.listdir(dataset_path)\n                if bf.isdir(bf.join(dataset_path, x)) and x.isnumeric()"
        },
        {
            "comment": "This function retrieves the sorted neuron indices from explanations for a given layer. It does this by joining the explanation path with the layer number, listing all files in that directory, filtering numeric filenames, converting them to integers, and finally sorting the resulting list.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/explanations/explanations.py\":217-229",
            "content": "            ]\n        )\n    ]\ndef get_sorted_neuron_indices_from_explanations(\n    explanations_path: str, layer: Union[str, int]\n) -> list[int]:\n    \"\"\"Return the indices of all neurons in this layer, in ascending order.\"\"\"\n    layer_dir = bf.join(explanations_path, str(layer))\n    return sorted(\n        [int(f.split(\".\")[0]) for f in bf.listdir(layer_dir) if f.split(\".\")[0].isnumeric()]\n    )"
        }
    ]
}