{
    "summary": "The fast dataclass utility offers efficient serialization and deserialization with limited data validation, using orjson for numpy objects. It includes unit tests, a function to register new dataclasses, and a recursive object hook for handling lists and dictionaries.",
    "details": [
        {
            "comment": "The code defines a fast dataclass utility that provides efficient serialization and deserialization while limiting data validation. The library ensures fields are not tuples to avoid issues during serialization and deserialization. The unit tests in the codebase demonstrate how to use this fast dataclass utility. It uses orjson for serializing numpy objects and provides a function to register new dataclasses with the utility.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/fast_dataclasses/fast_dataclasses.py\":0-36",
            "content": "# Utilities for dataclasses that are very fast to serialize and deserialize, with limited data\n# validation. Fields must not be tuples, since they get serialized and then deserialized as lists.\n#\n# The unit tests for this library show how to use it.\nimport json\nfrom dataclasses import dataclass, field, fields, is_dataclass\nfrom functools import partial\nfrom typing import Any, Union\nimport orjson\ndataclasses_by_name = {}\ndataclasses_by_fieldnames = {}\n@dataclass\nclass FastDataclass:\n    dataclass_name: str = field(init=False)\n    def __post_init__(self) -> None:\n        self.dataclass_name = self.__class__.__name__\ndef register_dataclass(cls):  # type: ignore\n    assert is_dataclass(cls), \"Only dataclasses can be registered.\"\n    dataclasses_by_name[cls.__name__] = cls\n    name_set = frozenset(f.name for f in fields(cls) if f.name != \"dataclass_name\")\n    dataclasses_by_fieldnames[name_set] = cls\n    return cls\ndef dumps(obj: Any) -> bytes:\n    return orjson.dumps(obj, option=orjson.OPT_SERIALIZE_NUMPY)\ndef _object_hook(d: Any, backwards_compatible: bool = True) -> Any:"
        },
        {
            "comment": "Checks if the input is a list, if so it recursively applies the object hook to each element. If not a list or dict, returns as is. If a dict, tries to find the corresponding dataclass based on either \"dataclass_name\" key or fieldnames, falling back if backwards_compatible is set to True.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/fast_dataclasses/fast_dataclasses.py\":37-60",
            "content": "    # If d is a list, recurse.\n    if isinstance(d, list):\n        return [_object_hook(x, backwards_compatible=backwards_compatible) for x in d]\n    # If d is not a dict, return it as is.\n    if not isinstance(d, dict):\n        return d\n    cls = None\n    if \"dataclass_name\" in d:\n        if d[\"dataclass_name\"] in dataclasses_by_name:\n            cls = dataclasses_by_name[d[\"dataclass_name\"]]\n        else:\n            assert backwards_compatible, (\n                f\"Dataclass {d['dataclass_name']} not found, set backwards_compatible=True if you \"\n                f\"are okay with that.\"\n            )\n    # Load objects created without dataclass_name set.\n    else:\n        # Try our best to find a dataclass if backwards_compatible is True.\n        if backwards_compatible:\n            d_fields = frozenset(d.keys())\n            if d_fields in dataclasses_by_fieldnames:\n                cls = dataclasses_by_fieldnames[d_fields]\n            elif len(d_fields) > 0:\n                # Check if the fields are a subset of a dataclass (if the dataclass had extra fields"
        },
        {
            "comment": "The code aims to load and parse JSON data that uses dataclasses. It checks for the compatibility of the loaded data with existing dataclass definitions, then creates a new dataclass instance or a dictionary based on the input.",
            "location": "\"/media/root/Toshiba XG3/works/automated-interpretability/docs/src/neuron-explainer/neuron_explainer/fast_dataclasses/fast_dataclasses.py\":61-84",
            "content": "                # added since the data was created). Note that this will fail if fields were removed\n                # from the dataclass.\n                for key, possible_cls in dataclasses_by_fieldnames.items():\n                    if d_fields.issubset(key):\n                        cls = possible_cls\n                        break\n                else:\n                    print(f\"Could not find dataclass for {d_fields} {cls}\")\n    new_d = {\n        k: _object_hook(v, backwards_compatible=backwards_compatible)\n        for k, v in d.items()\n        if k != \"dataclass_name\"\n    }\n    if cls is not None:\n        return cls(**new_d)\n    else:\n        return new_d\ndef loads(s: Union[str, bytes], backwards_compatible: bool = True) -> Any:\n    return json.loads(\n        s,\n        object_hook=partial(_object_hook, backwards_compatible=backwards_compatible),\n    )"
        }
    ]
}